# 41.缺失的第一个正数

## 问题
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

```
示例 1:
输入: [1,2,0]
输出: 3

示例 2:
输入: [3,4,-1,1]
输出: 2

示例 3:
输入: [7,8,9,11,12]
输出: 1
```

**说明:**
你的算法的时间复杂度应为`O(n)`，并且只能使用常数级别的空间。

## 解答
这道题想了很久。破解这道题的关键是，发现所要找的结果，也就是缺失的第一个正数，是[1..n]中的一个数。

根据这个思路，并且题目要求时间复杂度为`O(n)`，只能使用常数空间，很容易想到之前有些题的套路就是把信息记录在`nums`中。回到这道题，所需要记录的信息就是[1..n]中，有哪些数出现了。思考一下，可以确定记录信息的方式，就是对于出现的数x（x在[1..n]中），把nums[x-1]改写为x。所以，我们的问题就转换成了，把nums中所有1到n之间的数x，对应的位置，也就是nums[x-1]改写成x，通过这种方式来打标记。然后，再遍历一遍数组，找到第一个没有被标记的位置，返回其对应的值。

另外，一个小问题就是，可能我们找到一个x属于[1,n]，但是对应的位置nums[x-1]的数也是属于[1,n]，如果直接覆盖就会出问题，那么解决方式是将nums[x]和nums[nums[x]-1]交换一下，直到对应的位置的值不是[1,n]或者已经打了标记。

```python
class Solution:
    def firstMissingPositive(self, nums):
        n = len(nums)
        for i in range(0, n):
            while nums[i] >= 1 and nums[i] < n+1 and nums[i] != i+1 and nums[nums[i]-1] != nums[i]:
                nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1]
        for i in range(0, n):
            if nums[i] != i+1:
                return i+1
        return n+1

```
