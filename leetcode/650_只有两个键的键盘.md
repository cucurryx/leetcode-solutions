# 650.只有两个键的键盘

## 问题
最初在一个记事本上只有一个字符 &#39;A&#39;。你每次可以对这个记事本进行两种操作：

- Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。
- Paste (粘贴) : 你可以粘贴你上一次复制的字符。

给定一个数字`n`。你需要使用最少的操作次数，在记事本中打印出恰好`n`个 &#39;A&#39;。输出能够打印出`n`个 &#39;A&#39; 的最少操作次数。

```
示例 1:

输入: 3
输出: 3
解释:
最初, 我们只有一个字符 &#39;A&#39;。
第 1 步, 我们使用 Copy All 操作。
第 2 步, 我们使用 Paste 操作来获得 &#39;AA&#39;。
第 3 步, 我们使用 Paste 操作来获得 &#39;AAA&#39;。
```

说明:

- `n`的取值范围是 [1, 1000] 。


## 解答
很容易推测出来，`dp[i]`可以根据前面的`dp[i/k]`得到，但是一定要`k`是`i`的因子，所以`dp[i] = min(dp[i], dp[i/k]+k)`。也就是说，`dp[i]`可以由`dp[i/k]`复制一次，然后粘贴`k-1`次得到。

```python
class Solution:
    def minSteps(self, n):
        dp = [2 ** 31 - 1] * (n + 1)
        dp[0], dp[1] = 0, 0
        for i in range(2, n+1):
            for k in range(2, i+1):
                if i % k == 0:
                    dp[i] = min(dp[i], dp[int(i/k)]+k)
        return dp[n]    
```

这个算法的时间复杂度是`O(n*n)`。可以进一步优化到`O(n)`。思考一下，其实就是找到`n`的一个因子，假设为`k`，然后一直除下去，直到变成1。其实结果就是所有这样的因子`k`的和。也就是说，这道题的本质就是找`n`这个数，分解成一堆质数之积，然后求这些质数的和。

```python
class Solution:
    def minSteps(self, n):
        result = 0
        while n != 1:
            k = 2
            while n % k != 0:
                k += 1
            result += k
            n = n // k
        return result
```
