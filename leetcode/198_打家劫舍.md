# 198. 打家劫舍

## 问题

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:
```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 2:
```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = = 2 + 9 + 1 = 12 。
```

## 解答
首先，看到问题，暴力求解的复杂度会是指数级别的，于是不用考虑。而一般，出现这个问题的话，我们都会用DP的思想来求解。

观察数组，我们从第一个元素开始，那么解就是这个元素的值。将后面的元素逐个加入进来，会发现，就只有两种情况，这个偷或者不偷，并且都和前面的子问题的解有关。于是，可以得到状态方程，然后求解之:
`result[i] = max(result[i-1], result[i-2]+nums[i])`。

刚开始的时候，我使用了数组来存储解决问题过程中的所有子问题的解，但是看到别人的解法，发现可以进行优化。观察状态方程，每个状态只和前面两个有关，所有我们只需要两个变量就可以解决了，然后滚动更新。

时间复杂度O(n)，空间复杂度O(1)。

```C++
class Solution {
public:
    //result[i] = max(result[i-1], result[i-2]+nums[i])
    int rob(vector<int>& nums) {
        if (nums.empty() || nums.size() == 1) {
            return nums.empty() ? 0 : nums.front();
        }
        int res_i_2 = nums[0];
        int res_i_1 = max(nums[1], nums[0]);
        int res = res_i_1;
        for (int i = 2; i < nums.size(); ++i) {
            res = max(res_i_1, res_i_2 + nums[i]);
            res_i_2 = res_i_1;
            res_i_1 = res;
        }
        return res;
    }
};
```