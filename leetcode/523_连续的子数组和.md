# 523.连续的子数组和

## 问题
给定一个包含非负数的数组和一个目标整数`k`，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。

```
示例 1:
输入: [23,2,4,6,7], k = 6
输出: True
解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。

示例 2:
输入: [23,2,6,4,7], k = 6
输出: True
解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。
```

说明:
- 数组的长度不会超过10,000。
- 你可以认为所有数字总和在 32 位有符号整数范围内。


## 解答
[560_和为K的子数组.md](./560_和为K的子数组.md)，和这题套路差不多。最暴力的方法就是用两层遍历来做。比较好的就是，用一个哈希表，来记录每个sum出现的最左边的位置。然后，这里的`sum`，都做取模处理，这样所有记录的sum都是0到k之间。那么，如果我们在遍历的是否，能够找到两个相等的sum，并且距离该sum最左边出现的位置超过1（为了满足至少长度为2的子数组条件），就可以返回true。

所以，这道题最中心的思想是，记录下每个sum出现的最左边位置，而且取模。

```C++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> m {{0, -1}};
        int result = 0, sum = 0;
        for (int i = 0; i < nums.size(); ++i) {
            auto x = nums[i];
            sum += x;
            if (k != 0) {
                sum %= k;     
            }
            if (m.count(sum) && i - m[sum] > 1) {
                return true;
            }
            if (m.count(sum) == 0) {
                m[sum] = i;
            }
        }
        return false;
    }
};
```
