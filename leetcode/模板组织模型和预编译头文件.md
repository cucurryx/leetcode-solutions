# 模板组织模型和预编译头文件

### 模板组织模型
主要有三种：包含模型，显式实例化和分离模型。之所以需要不同于普通C++代码组织方式，是因为模板的特殊原因，导致编译器-链接器这个编译系统不能够正常编译C++模板。

如果我们把声明放在`a.h`，定义放在`a.cc`，然后在`main.cc`中`#include<a.h>`，并使用模板，那么会出现链接错误。因为，编译`a.cc`的时候不知道有谁引用了它，所以不会实例化，而`main.cc`中会默认生成了对应的模板实体，会引用相关实体。最后，引用了，但是实际不存在的实体。

为了解决这个问题，可以在`a_def.h`中来定义模板，然后`main.cc`中`#include<a_def.h>`，这样就是包含模型了。这个模型的弊端在于可能include进来很多无用的代码，导致编译需要很长时间。

显式实例化就是显式地将模板实例化，这样就不会出现上面的问题。实现方式是，`b.cc`中显式实例化`a_def.h`中的模板，然后`main.cc`就直接`#include<a.h>`，而不用`#include<a_def.h>`了。这样做的弊端在于，庞大的项目来手工实例化，会十分麻烦。显式实例化方式：
```C++
template
const std::string &fuck(const std::string &s);

//本来的声明:
template <typename T>
const T &fuck(const T &)；
```

另外，分离模型就是借助于`export`关键字。在模板的声明和定义（定义处不强制要求）处的`template`前面加上`export`关键字，这样声明放在`a.h`，定义放在`a.cc`，在`main.cc`中`#include <a.h>`也不会有问题了。这种方式，会让编译单元之间产生某种隐藏的耦合关系。如果`a.cc`修改了，那么`main.cc`也需要重新编译。这种耦合关系是不可见的，会导致依赖性管理工具使用出问题（比如make）。这种耦合关系和包含模型其实没有本质的区别。

一般来说，都是建议用 **包含模型**。

### 预编译头文件
如果相同的代码被重复编译了很多次，这是十分浪费资源的。所以，预编译头文件的思想就是把很多代码中前面重复的代码一次编译，然后重复使用，来优化编译的时间。比如，我们可以把
```C++
#include <iostream>
#include <vector>
#include <string>
...
```
这样会被重复使用的头文件都放进一个`std.h`，然后每次就只需要`#include <std.h>`。当然，这样也会更灵活的管理预编译头文件，就是进行分层。按照头文件使用的稳定性和频率进行分层，然后在按照需求来使用就ok了。

比如:
```C++
//core.h
#include "std.h"
#include "core_data.h"
#include "core_algos.h"
```
这里core.h的稳定性低于std.h，所以，可以分层使用了。

**为了充分使用预编译这个功能，统一安排#include的顺序是十分重要，一定要相同。**