# 91.解码方法

## 问题
一条包含字母`A-Z` 的消息通过以下方式进行了编码：
&#39;A&#39; -> 1
&#39;B&#39; -> 2
...
&#39;Z&#39; -> 26

给定一个只包含数字的非空字符串，请计算解码方法的总数。
```
示例 1:
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2:
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

## 解答
可以根据前面的子问题来进行求解。`dp[i]`存储`s[:i]`的结果，如果`s[i]`可以和前面的字符组成一个合法的编码，那么`dp[i+1] = dp[i] + dp[i-1]`了，前提是`s[i]`不为`"0"`，否则就是`dp[i-1]`。如果`s[i]`和前面字符不能够组成一个合法的编码，那么就是直接`dp[i+1] = dp[i]`了，也就是只有`s[i]`这个单独的编码。如果存在`"00"`的情况，那么就不能够组成任何合法的编码了，返回0。

为了方便处理越界的问题，这里用`dp[i+1]`来存储`s[:i]`子问题的解。

```python
class Solution:
    def numDecodings(self, s):
        dp = [0 for _ in range(len(s)+1)]
        if s[0] != "0":
            dp[0], dp[1] = 1, 1
        for i in range(1, len(s)):
            if s[i-1] != "0" and int(s[i-1:i+1]) <= 26:
                if s[i] != "0":
                    dp[i+1] = dp[i] + dp[i-1]
                else:
                    dp[i+1] = dp[i-1]
            else:
                if s[i] != "0":
                    dp[i+1] = dp[i]
                else:
                    return 0
        return dp[-1]
```
