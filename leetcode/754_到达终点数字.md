# 754. 到达终点数字

## 问题

在一根无限长的数轴上，你站在0的位置。终点在target的位置。

每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。

返回到达终点需要的最小移动次数。

**示例 1:**
```
输入: target = 3
输出: 2
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 3 。
```

**示例 2:**
```
输入: target = 2
输出: 3
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。
```
**注意:**
target是在[-10^9, 10^9]范围中的非零整数。

## 解答
仔细想想就是[1, n]里面的数，去可以取负号或者正号，然后和为target。那么，就是相当于将1到n分成了两个部分，假设为x和y。于是有:
```
sum = (n+1)*n/2;
x + y = sum;
x - y = target;
```
所以，只要n能够满足这个方程，就是能够满足target的解了。

从1开始遍历，注意这里一定要求x和y为整数。然后，考虑负数的情况就行。这样的时间复杂度是O(n)。

```C++
class Solution {
public:
    int reachNumber(int target) {
        int n = 0;
        while (++n) {
            int sum = n * (n + 1) / 2;
            if (sum >= abs(target) && (sum + target) % 2 == 0 
                && (sum - target) % 2 == 0) {
                return n;
            }
        }
    }
};
```
