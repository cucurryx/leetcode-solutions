# 343. 整数拆分

## 问题
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

例如，给定 n = 2，返回1（2 = 1 + 1）；给定 n = 10，返回36（10 = 3 + 3 + 4）。

注意：你可以假设 n 不小于2且不大于58。

## 解答
问题很简单，也很容易观察出应该用DP来解。首先，分析一下，用a[n]来表示n的结果，而这个问题和子问题之间的关系很容易发现，就是从1..n之间找到一个分割点，然后就分成两个子问题，利用a[]存储的子问题的解，就可以解决原问题了。

根据这个思路，可以得到递归式: `a[n] = max(a[i] * a[n-i] for i in [1..n-1])`。这个并不完全正确，因为我们分割成i和n-i两个部分后，子问题i的解不一定是分割i得到的，还有可能就是i本身。所以需要多加一个max()。

很容易分析时间复杂度和空间复杂度都是O(n)的。

```C++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> vec(n+1, 1);
        for (int i = 2; i <= n; ++i) {
            for (int j = i/2; j < i; ++j) {
                int x = max(j, vec[j]);
                int y = max(i-j, vec[i-j]);
                vec[i] = max(x*y, vec[i]);
            }
        }
        return vec.back();
    }
};
```